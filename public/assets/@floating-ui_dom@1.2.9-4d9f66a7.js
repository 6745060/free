import{r as Q,l as X}from"./@floating-ui_core@1.2.6-614032f8.js";function h(t){var e;return((e=t.ownerDocument)==null?void 0:e.defaultView)||window}function g(t){return h(t).getComputedStyle(t)}function Y(t){return t instanceof h(t).Node}function L(t){return Y(t)?(t.nodeName||"").toLowerCase():""}function x(t){return t instanceof h(t).HTMLElement}function v(t){return t instanceof h(t).Element}function M(t){return typeof ShadowRoot>"u"?!1:t instanceof h(t).ShadowRoot||t instanceof ShadowRoot}function E(t){const{overflow:e,overflowX:n,overflowY:o,display:i}=g(t);return/auto|scroll|overlay|hidden|clip/.test(e+o+n)&&!["inline","contents"].includes(i)}function U(t){return["table","td","th"].includes(L(t))}function k(t){const e=V(),n=g(t);return n.transform!=="none"||n.perspective!=="none"||!e&&!!n.backdropFilter&&n.backdropFilter!=="none"||!e&&!!n.filter&&n.filter!=="none"||["transform","perspective","filter"].some(o=>(n.willChange||"").includes(o))||["paint","layout","strict","content"].some(o=>(n.contain||"").includes(o))}function V(){return!(typeof CSS>"u"||!CSS.supports)&&CSS.supports("-webkit-backdrop-filter","none")}function F(t){return["html","body","#document"].includes(L(t))}const O=Math.min,S=Math.max,D=Math.round;function _(t){const e=g(t);let n=parseFloat(e.width)||0,o=parseFloat(e.height)||0;const i=x(t),r=i?t.offsetWidth:n,s=i?t.offsetHeight:o,c=D(n)!==r||D(o)!==s;return c&&(n=r,o=s),{width:n,height:o,fallback:c}}function $(t){return v(t)?t:t.contextElement}const j={x:1,y:1};function R(t){const e=$(t);if(!x(e))return j;const n=e.getBoundingClientRect(),{width:o,height:i,fallback:r}=_(e);let s=(r?D(n.width):n.width)/o,c=(r?D(n.height):n.height)/i;return s&&Number.isFinite(s)||(s=1),c&&Number.isFinite(c)||(c=1),{x:s,y:c}}const P={x:0,y:0};function q(t,e,n){var o,i;if(e===void 0&&(e=!0),!V())return P;const r=t?h(t):window;return!n||e&&n!==r?P:{x:((o=r.visualViewport)==null?void 0:o.offsetLeft)||0,y:((i=r.visualViewport)==null?void 0:i.offsetTop)||0}}function W(t,e,n,o){e===void 0&&(e=!1),n===void 0&&(n=!1);const i=t.getBoundingClientRect(),r=$(t);let s=j;e&&(o?v(o)&&(s=R(o)):s=R(t));const c=q(r,n,o);let f=(i.left+c.x)/s.x,l=(i.top+c.y)/s.y,a=i.width/s.x,d=i.height/s.y;if(r){const m=h(r),w=o&&v(o)?h(o):o;let p=m.frameElement;for(;p&&o&&w!==m;){const u=R(p),y=p.getBoundingClientRect(),T=getComputedStyle(p);y.x+=(p.clientLeft+parseFloat(T.paddingLeft))*u.x,y.y+=(p.clientTop+parseFloat(T.paddingTop))*u.y,f*=u.x,l*=u.y,a*=u.x,d*=u.y,f+=y.x,l+=y.y,p=h(p).frameElement}}return X({width:a,height:d,x:f,y:l})}function b(t){return((Y(t)?t.ownerDocument:t.document)||window.document).documentElement}function H(t){return v(t)?{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}:{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function z(t){return W(b(t)).left+H(t).scrollLeft}function C(t){if(L(t)==="html")return t;const e=t.assignedSlot||t.parentNode||M(t)&&t.host||b(t);return M(e)?e.host:e}function G(t){const e=C(t);return F(e)?e.ownerDocument.body:x(e)&&E(e)?e:G(e)}function I(t,e){var n;e===void 0&&(e=[]);const o=G(t),i=o===((n=t.ownerDocument)==null?void 0:n.body),r=h(o);return i?e.concat(r,r.visualViewport||[],E(o)?o:[]):e.concat(o,I(o))}function N(t,e,n){let o;if(e==="viewport")o=function(i,r){const s=h(i),c=b(i),f=s.visualViewport;let l=c.clientWidth,a=c.clientHeight,d=0,m=0;if(f){l=f.width,a=f.height;const w=V();(!w||w&&r==="fixed")&&(d=f.offsetLeft,m=f.offsetTop)}return{width:l,height:a,x:d,y:m}}(t,n);else if(e==="document")o=function(i){const r=b(i),s=H(i),c=i.ownerDocument.body,f=S(r.scrollWidth,r.clientWidth,c.scrollWidth,c.clientWidth),l=S(r.scrollHeight,r.clientHeight,c.scrollHeight,c.clientHeight);let a=-s.scrollLeft+z(i);const d=-s.scrollTop;return g(c).direction==="rtl"&&(a+=S(r.clientWidth,c.clientWidth)-f),{width:f,height:l,x:a,y:d}}(b(t));else if(v(e))o=function(i,r){const s=W(i,!0,r==="fixed"),c=s.top+i.clientTop,f=s.left+i.clientLeft,l=x(i)?R(i):{x:1,y:1};return{width:i.clientWidth*l.x,height:i.clientHeight*l.y,x:f*l.x,y:c*l.y}}(e,n);else{const i=q(t);o={...e,x:e.x-i.x,y:e.y-i.y}}return X(o)}function J(t,e){const n=C(t);return!(n===e||!v(n)||F(n))&&(g(n).position==="fixed"||J(n,e))}function B(t,e){return x(t)&&g(t).position!=="fixed"?e?e(t):t.offsetParent:null}function A(t,e){const n=h(t);if(!x(t))return n;let o=B(t,e);for(;o&&U(o)&&g(o).position==="static";)o=B(o,e);return o&&(L(o)==="html"||L(o)==="body"&&g(o).position==="static"&&!k(o))?n:o||function(i){let r=C(i);for(;x(r)&&!F(r);){if(k(r))return r;r=C(r)}return null}(t)||n}function Z(t,e,n){const o=x(e),i=b(e),r=n==="fixed",s=W(t,!0,r,e);let c={scrollLeft:0,scrollTop:0};const f={x:0,y:0};if(o||!o&&!r)if((L(e)!=="body"||E(i))&&(c=H(e)),x(e)){const l=W(e,!0,r,e);f.x=l.x+e.clientLeft,f.y=l.y+e.clientTop}else i&&(f.x=z(i));return{x:s.left+c.scrollLeft-f.x,y:s.top+c.scrollTop-f.y,width:s.width,height:s.height}}const tt={getClippingRect:function(t){let{element:e,boundary:n,rootBoundary:o,strategy:i}=t;const r=n==="clippingAncestors"?function(l,a){const d=a.get(l);if(d)return d;let m=I(l).filter(y=>v(y)&&L(y)!=="body"),w=null;const p=g(l).position==="fixed";let u=p?C(l):l;for(;v(u)&&!F(u);){const y=g(u),T=k(u);T||y.position!=="fixed"||(w=null),(p?!T&&!w:!T&&y.position==="static"&&w&&["absolute","fixed"].includes(w.position)||E(u)&&!T&&J(l,u))?m=m.filter(K=>K!==u):w=y,u=C(u)}return a.set(l,m),m}(e,this._c):[].concat(n),s=[...r,o],c=s[0],f=s.reduce((l,a)=>{const d=N(e,a,i);return l.top=S(d.top,l.top),l.right=O(d.right,l.right),l.bottom=O(d.bottom,l.bottom),l.left=S(d.left,l.left),l},N(e,c,i));return{width:f.right-f.left,height:f.bottom-f.top,x:f.left,y:f.top}},convertOffsetParentRelativeRectToViewportRelativeRect:function(t){let{rect:e,offsetParent:n,strategy:o}=t;const i=x(n),r=b(n);if(n===r)return e;let s={scrollLeft:0,scrollTop:0},c={x:1,y:1};const f={x:0,y:0};if((i||!i&&o!=="fixed")&&((L(n)!=="body"||E(r))&&(s=H(n)),x(n))){const l=W(n);c=R(n),f.x=l.x+n.clientLeft,f.y=l.y+n.clientTop}return{width:e.width*c.x,height:e.height*c.y,x:e.x*c.x-s.scrollLeft*c.x+f.x,y:e.y*c.y-s.scrollTop*c.y+f.y}},isElement:v,getDimensions:function(t){return _(t)},getOffsetParent:A,getDocumentElement:b,getScale:R,async getElementRects(t){let{reference:e,floating:n,strategy:o}=t;const i=this.getOffsetParent||A,r=this.getDimensions;return{reference:Z(e,await i(n),o),floating:{x:0,y:0,...await r(n)}}},getClientRects:t=>Array.from(t.getClientRects()),isRTL:t=>g(t).direction==="rtl"},nt=(t,e,n)=>{const o=new Map,i={platform:tt,...n},r={...i.platform,_c:o};return Q(t,e,{...i,platform:r})};export{nt as M};
